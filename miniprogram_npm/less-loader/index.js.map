{"version":3,"sources":["cjs.js","index.js","options.json","utils.js","LessError.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nmodule.exports = require('./index').default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _loaderUtils = require(\"loader-utils\");\n\nvar _schemaUtils = _interopRequireDefault(require(\"schema-utils\"));\n\nvar _options = _interopRequireDefault(require(\"./options.json\"));\n\nvar _utils = require(\"./utils\");\n\nvar _LessError = _interopRequireDefault(require(\"./LessError\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction lessLoader(source) {\n  const options = (0, _loaderUtils.getOptions)(this);\n  (0, _schemaUtils.default)(_options.default, options, {\n    name: 'Less Loader',\n    baseDataPath: 'options'\n  });\n  const callback = this.async();\n  const lessOptions = (0, _utils.getLessOptions)(this, options);\n  let data = source;\n\n  if (typeof options.prependData !== 'undefined') {\n    data = typeof options.prependData === 'function' ? `${options.prependData(this)}\\n${data}` : `${options.prependData}\\n${data}`;\n  }\n\n  if (typeof options.appendData !== 'undefined') {\n    data = typeof options.appendData === 'function' ? `${data}\\n${options.appendData(this)}` : `${data}\\n${options.appendData}`;\n  }\n\n  (0, _utils.getLessImplementation)(options.implementation).render(data, lessOptions).then(({\n    css,\n    map,\n    imports\n  }) => {\n    imports.forEach(item => {\n      // `less` return forward slashes on windows when `webpack` resolver return an absolute windows path in `WebpackFileManager`\n      // Ref: https://github.com/webpack-contrib/less-loader/issues/357\n      this.addDependency(_path.default.normalize(item));\n    });\n    callback(null, css, typeof map === 'string' ? JSON.parse(map) : map);\n  }).catch(lessError => {\n    if (lessError.filename) {\n      // `less` return forward slashes on windows when `webpack` resolver return an absolute windows path in `WebpackFileManager`\n      // Ref: https://github.com/webpack-contrib/less-loader/issues/357\n      this.addDependency(_path.default.normalize(lessError.filename));\n    }\n\n    callback(new _LessError.default(lessError));\n  });\n}\n\nvar _default = lessLoader;\nexports.default = _default;","module.exports = {\n  \"type\": \"object\",\n  \"properties\": {\n    \"lessOptions\": {\n      \"description\": \"Options to pass through to `Less` (https://github.com/webpack-contrib/less-loader#lessoptions).\",\n      \"anyOf\": [\n        {\n          \"type\": \"object\",\n          \"additionalProperties\": true\n        },\n        {\n          \"instanceof\": \"Function\"\n        }\n      ]\n    },\n    \"prependData\": {\n      \"description\": \"Prepends `Less` code before the actual entry file (https://github.com/webpack-contrib/less-loader#prependdata).\",\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"instanceof\": \"Function\"\n        }\n      ]\n    },\n    \"appendData\": {\n      \"description\": \"Add `Less` code after the actual entry file (https://github.com/webpack-contrib/less-loader#postponeddata).\",\n      \"anyOf\": [\n        {\n          \"type\": \"string\"\n        },\n        {\n          \"instanceof\": \"Function\"\n        }\n      ]\n    },\n    \"sourceMap\": {\n      \"description\": \"Enables/Disables generation of source maps (https://github.com/webpack-contrib/less-loader#sourcemap).\",\n      \"type\": \"boolean\"\n    },\n    \"implementation\": {\n      \"description\": \"The implementation of the `Less` to be used (https://github.com/webpack-contrib/less-loader#implementation).\",\n      \"type\": \"object\"\n    }\n  },\n  \"additionalProperties\": false\n}\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLessImplementation = getLessImplementation;\nexports.getLessOptions = getLessOptions;\n\nvar _less = _interopRequireDefault(require(\"less\"));\n\nvar _clone = _interopRequireDefault(require(\"clone\"));\n\nvar _loaderUtils = require(\"loader-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint-disable class-methods-use-this */\nconst trailingSlash = /[/\\\\]$/; // This somewhat changed in Less 3.x. Now the file name comes without the\n// automatically added extension whereas the extension is passed in as `options.ext`.\n// So, if the file name matches this regexp, we simply ignore the proposed extension.\n\nconst isModuleName = /^~([^/]+|[^/]+\\/|@[^/]+[/][^/]+|@[^/]+\\/?|@[^/]+[/][^/]+\\/)$/;\n/**\n * Creates a Less plugin that uses webpack's resolving engine that is provided by the loaderContext.\n *\n * @param {LoaderContext} loaderContext\n * @returns {LessPlugin}\n */\n\nfunction createWebpackLessPlugin(loaderContext) {\n  const resolve = loaderContext.getResolve({\n    mainFields: ['less', 'style', 'main', '...'],\n    mainFiles: ['index', '...'],\n    extensions: ['.less', '.css']\n  });\n\n  class WebpackFileManager extends _less.default.FileManager {\n    supports(filename) {\n      if (this.isPathAbsolute(filename)) {\n        return false;\n      }\n\n      return true;\n    } // Sync resolving is used at least by the `data-uri` function.\n    // This file manager doesn't know how to do it, so let's delegate it\n    // to the default file manager of Less.\n    // We could probably use loaderContext.resolveSync, but it's deprecated,\n    // see https://webpack.js.org/api/loaders/#this-resolvesync\n\n\n    supportsSync() {\n      return false;\n    }\n\n    getUrl(filename, options) {\n      if (options.ext && !isModuleName.test(filename)) {\n        return this.tryAppendExtension(filename, options.ext);\n      }\n\n      return filename;\n    }\n\n    async resolveFilename(filename, currentDirectory, options) {\n      const url = this.getUrl(filename, options);\n      const moduleRequest = (0, _loaderUtils.urlToRequest)(url, url.charAt(0) === '/' ? '' : null); // Less is giving us trailing slashes, but the context should have no trailing slash\n\n      const context = currentDirectory.replace(trailingSlash, '');\n      return this.resolveRequests(context, [moduleRequest, url]);\n    }\n\n    resolveRequests(context, possibleRequests) {\n      if (possibleRequests.length === 0) {\n        return Promise.reject();\n      }\n\n      return resolve(context, possibleRequests[0]).then(result => {\n        return result;\n      }).catch(error => {\n        const [, ...tailPossibleRequests] = possibleRequests;\n\n        if (tailPossibleRequests.length === 0) {\n          throw error;\n        }\n\n        return this.resolveRequests(context, tailPossibleRequests);\n      });\n    }\n\n    async loadFile(filename, ...args) {\n      let result;\n\n      try {\n        if (isModuleName.test(filename)) {\n          const error = new Error();\n          error.type = 'Next';\n          throw error;\n        }\n\n        result = await super.loadFile(filename, ...args);\n      } catch (error) {\n        if (error.type !== 'File' && error.type !== 'Next') {\n          return Promise.reject(error);\n        }\n\n        try {\n          result = await this.resolveFilename(filename, ...args);\n        } catch (webpackResolveError) {\n          error.message = `Less resolver error:\\n${error.message}\\n\\n` + `Webpack resolver error details:\\n${webpackResolveError.details}\\n\\n` + `Webpack resolver error missing:\\n${webpackResolveError.missing}\\n\\n`;\n          return Promise.reject(error);\n        }\n\n        loaderContext.addDependency(result);\n        return super.loadFile(result, ...args);\n      }\n\n      loaderContext.addDependency(result.filename);\n      return result;\n    }\n\n  }\n\n  return {\n    install(lessInstance, pluginManager) {\n      pluginManager.addFileManager(new WebpackFileManager());\n    },\n\n    minVersion: [3, 0, 0]\n  };\n}\n/**\n * Get the less options from the loader context and normalizes its values\n *\n * @param {object} loaderContext\n * @param {object} loaderOptions\n * @returns {Object}\n */\n\n\nfunction getLessOptions(loaderContext, loaderOptions) {\n  const options = (0, _clone.default)(loaderOptions.lessOptions ? typeof loaderOptions.lessOptions === 'function' ? loaderOptions.lessOptions(loaderContext) || {} : loaderOptions.lessOptions : {});\n  const lessOptions = {\n    plugins: [],\n    relativeUrls: true,\n    // We need to set the filename because otherwise our WebpackFileManager will receive an undefined path for the entry\n    filename: loaderContext.resourcePath,\n    ...options\n  };\n  lessOptions.plugins.unshift(createWebpackLessPlugin(loaderContext));\n  const useSourceMap = typeof loaderOptions.sourceMap === 'boolean' ? loaderOptions.sourceMap : loaderContext.sourceMap;\n\n  if (useSourceMap) {\n    lessOptions.sourceMap = {\n      outputSourceFiles: true\n    };\n  }\n\n  return lessOptions;\n}\n\nfunction getLessImplementation(implementation) {\n  if (typeof implementation !== 'undefined') {\n    return implementation;\n  }\n\n  return _less.default;\n}","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass LessError extends Error {\n  constructor(error) {\n    super();\n    this.message = ['\\n', ...LessError.getFileExcerptIfPossible(error), error.message.charAt(0).toUpperCase() + error.message.slice(1), `      Error in ${_path.default.normalize(error.filename)} (line ${error.line}, column ${error.column})`].join('\\n');\n    this.hideStack = true;\n  }\n\n  static getFileExcerptIfPossible(lessErr) {\n    if (typeof lessErr.extract === 'undefined') {\n      return [];\n    }\n\n    const excerpt = lessErr.extract.slice(0, 2);\n    const column = Math.max(lessErr.column - 1, 0);\n\n    if (typeof excerpt[0] === 'undefined') {\n      excerpt.shift();\n    }\n\n    excerpt.push(`${new Array(column).join(' ')}^`);\n    return excerpt;\n  }\n\n}\n\nvar _default = LessError;\nexports.default = _default;"]}